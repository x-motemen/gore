package gore

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func chdir(dir string) func() {
	d, _ := os.Getwd()
	os.Chdir(dir)
	return func() { os.Chdir(d) }
}

func gomodSetup(t *testing.T) {
	tempDir := newTempDir(t)
	mod1Dir := filepath.Join(tempDir, "mod1")
	require.NoError(t, os.Mkdir(mod1Dir, 0o700))
	require.NoError(t, os.WriteFile(filepath.Join(mod1Dir, "go.mod"), []byte(`module mod1
`), 0o600))
	require.NoError(t, os.WriteFile(filepath.Join(mod1Dir, "mod1.go"), []byte(`package mod1

const Value = 10
`), 0o600))

	mod2Dir := filepath.Join(tempDir, "mod2")
	require.NoError(t, os.Mkdir(mod2Dir, 0o700))
	require.NoError(t, os.WriteFile(filepath.Join(mod2Dir, "go.mod"), []byte(fmt.Sprintf(`module mod2

replace mod1 => %s

require mod1 v0.0.0-00010101000000-000000000000
`, strconv.Quote(mod1Dir))), 0o600))
	require.NoError(t, os.WriteFile(filepath.Join(mod2Dir, "mod2.go"), []byte(`package mod2

import "mod1"

func Foo() int {
	return mod1.Value
}
`), 0o600))

	mod3Dir := filepath.Join(mod2Dir, "mod3")
	require.NoError(t, os.Mkdir(mod3Dir, 0o700))
	require.NoError(t, os.WriteFile(filepath.Join(mod3Dir, "mod3.go"), []byte(`package mod3

func Bar() string {
	return "mod3"
}
`), 0o600))

	mod4Dir := filepath.Join(mod2Dir, "mod4")
	require.NoError(t, os.Mkdir(mod4Dir, 0o700))

	t.Cleanup(chdir(mod2Dir))
}

func TestSessionEval_Gomod(t *testing.T) {
	var stdout, stderr strings.Builder
	gomodSetup(t)
	s, err := NewSession(&stdout, &stderr)
	t.Cleanup(func() { s.Clear() })
	require.NoError(t, err)

	codes := []string{
		`:i mod2`,
		`mod2.Foo()`,
		`mod2.Foo() + mod2.Foo()`,
		`:clear`,
		`:i mod2`,
		`mod2.Foo()`,
		`:i mod1`,
		`3 * mod1.Value`,
	}

	for _, code := range codes {
		_ = s.Eval(code)
	}

	assert.Equal(t, "10\n20\n10\n30\n", stdout.String())
	assert.Equal(t, ``, stderr.String())
}

func TestSessionEval_Gomod_AutoImport(t *testing.T) {
	var stdout, stderr strings.Builder
	gomodSetup(t)
	s, err := NewSession(&stdout, &stderr)
	t.Cleanup(func() { s.Clear() })
	require.NoError(t, err)
	s.autoImport = true

	codes := []string{
		`mod2.Foo()`,
		`mod2.Foo() + mod2.Foo()`,
		`:clear`,
		`mod2.Foo()`,
		`3 * mod1.Value`,
		`:t mod2.Foo`,
		`:d mod2.Foo`,
		`mod3.Bar()`,
		`:t mod3.Bar`,
	}

	for _, code := range codes {
		_ = s.Eval(code)
	}

	assert.Equal(t, `10
20
10
30
func() int
package mod2 // import "mod2"

func Foo() int
"mod3"
func() string
`, stdout.String())
	assert.Equal(t, ``, stderr.String())
}

func TestSessionEval_Gomod_DeepDir(t *testing.T) {
	var stdout, stderr strings.Builder
	gomodSetup(t)
	require.NoError(t, os.Mkdir("tmp", 0o700))
	require.NoError(t, os.Chdir("tmp"))
	s, err := NewSession(&stdout, &stderr)
	t.Cleanup(func() { s.Clear() })
	require.NoError(t, err)

	codes := []string{
		`:i mod2`,
		`mod2.Foo()`,
		`mod2.Foo() + mod2.Foo()`,
		`:clear`,
		`:i mod2`,
		`mod2.Foo()`,
		`:i mod1`,
		`3 * mod1.Value`,
	}

	for _, code := range codes {
		_ = s.Eval(code)
	}

	assert.Equal(t, "10\n20\n10\n30\n", stdout.String())
	assert.Equal(t, ``, stderr.String())
}

func TestSessionEval_Gomod_Outside(t *testing.T) {
	var stdout, stderr strings.Builder
	_ = newTempDir(t)
	s, err := NewSession(&stdout, &stderr)
	t.Cleanup(func() { s.Clear() })
	require.NoError(t, err)

	codes := []string{
		`:i github.com/confetti-framework/baker`,
		`gore.Session{}`,
	}

	for _, code := range codes {
		_ = s.Eval(code)
	}

	assert.Equal(t, ``, stderr.String())
}

func TestSessionEval_Gomod_CompleteImport(t *testing.T) {
	var stdout, stderr strings.Builder
	gomodSetup(t)
	s, err := NewSession(&stdout, &stderr)
	t.Cleanup(func() { s.Clear() })
	require.NoError(t, err)

	pre, cands, post := s.completeWord(":i ", 3)
	assert.Equal(t, ":i ", pre)
	assert.Subset(t, cands, []string{"mod2", "mod1"})
	assert.Equal(t, post, "")

	pre, cands, post = s.completeWord(":i mod2/", 8)
	assert.Equal(t, ":i ", pre)
	assert.Subset(t, cands, []string{"mod2/mod3", "mod2/mod4"})
	assert.Equal(t, post, "")
}
